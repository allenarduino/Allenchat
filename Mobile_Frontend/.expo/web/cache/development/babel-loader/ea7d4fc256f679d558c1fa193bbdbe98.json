{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { NetworkStateType } from \"./Network.types\";\nexport default {\n  getIpAddressAsync: function getIpAddressAsync() {\n    var resp, data;\n    return _regeneratorRuntime.async(function getIpAddressAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return _regeneratorRuntime.awrap(fetch('https://api.ipify.org?format=json'));\n\n          case 3:\n            resp = _context.sent;\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(resp.json());\n\n          case 6:\n            data = _context.sent;\n            return _context.abrupt(\"return\", data.ip);\n\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context[\"catch\"](0);\n            throw _context.t0;\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, [[0, 10]], Promise);\n  },\n  getNetworkStateAsync: function getNetworkStateAsync() {\n    var type, isConnected, isInternetReachable;\n    return _regeneratorRuntime.async(function getNetworkStateAsync$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            type = navigator.onLine ? NetworkStateType.UNKNOWN : NetworkStateType.NONE;\n            isConnected = navigator.onLine;\n            isInternetReachable = isConnected;\n            return _context2.abrupt(\"return\", {\n              type: type,\n              isConnected: isConnected,\n              isInternetReachable: isInternetReachable\n            });\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getMacAddressAsync: function getMacAddressAsync() {\n    return _regeneratorRuntime.async(function getMacAddressAsync$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", null);\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/ExpoNetwork.web.ts"],"names":[],"mappings":";AAAA,SAAuB,gBAAvB;AAEA,eAAe;AACP,EAAA,iBADO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAGU,KAAK,CAAC,mCAAD,CAHf;;AAAA;AAGH,YAAA,IAHG;AAAA;AAAA,6CAIU,IAAI,CAAC,IAAL,EAJV;;AAAA;AAIH,YAAA,IAJG;AAAA,6CAKF,IAAI,CAAC,EALH;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUP,EAAA,oBAVO;AAAA;AAAA;AAAA;AAAA;AAAA;AAWL,YAAA,IAXK,GAWE,SAAS,CAAC,MAAV,GAAmB,gBAAgB,CAAC,OAApC,GAA8C,gBAAgB,CAAC,IAXjE;AAYL,YAAA,WAZK,GAYS,SAAS,CAAC,MAZnB;AAaL,YAAA,mBAbK,GAaiB,WAbjB;AAAA,8CAcJ;AACL,cAAA,IAAI,EAAJ,IADK;AAEL,cAAA,WAAW,EAAX,WAFK;AAGL,cAAA,mBAAmB,EAAnB;AAHK,aAdI;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBP,EAAA,kBApBO;AAAA;AAAA;AAAA;AAAA;AAAA,8CAqBJ,IArBI;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAf","sourcesContent":["import { NetworkState, NetworkStateType } from './Network.types';\n\nexport default {\n  async getIpAddressAsync(): Promise<string> {\n    try {\n      const resp = await fetch('https://api.ipify.org?format=json');\n      const data = await resp.json();\n      return data.ip;\n    } catch (e) {\n      throw e;\n    }\n  },\n  async getNetworkStateAsync(): Promise<NetworkState> {\n    const type = navigator.onLine ? NetworkStateType.UNKNOWN : NetworkStateType.NONE;\n    const isConnected = navigator.onLine;\n    const isInternetReachable = isConnected;\n    return {\n      type,\n      isConnected,\n      isInternetReachable,\n    };\n  },\n  async getMacAddressAsync(): Promise<null> {\n    return null;\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}